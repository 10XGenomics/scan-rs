use crate::polevl::{p1evl, polevl};

const EXPN2: f64 = 0.135_335_283_236_612_7; // exp(-2)
const S2PI: f64 = 2.506_628_274_631_000_7; // sqrt(2pi)

// approximation for 0 <= |y - 0.5| <= 3/8
const P0: &[f64] = &[
    -5.996_335_010_141_079E1,
    9.800_107_541_859_997E1,
    -5.667_628_574_690_703E1,
    1.393_126_093_872_796_8E1,
    -1.239_165_838_673_812_5,
];
const Q0: &[f64] = &[
    1.954_488_583_381_417_6,
    4.676_279_128_988_815,
    8.636_024_213_908_905E1,
    -2.254_626_878_541_193_7E2,
    2.002_602_123_800_606_6E2,
    -8.203_722_561_683_334E1,
    1.590_562_251_262_117E1,
    -1.183_316_211_213_3,
];

// approximation for interval z = sqrt( -2 log y ) between 2 and 8
const P1: &[f64] = &[
    4.055_448_923_059_624_5,
    3.152_510_945_998_938_8E1,
    5.716_281_922_464_213E1,
    4.408_050_738_932_008E1,
    1.468_495_619_288_580_3E1,
    2.186_633_068_507_902_5,
    -1.402_560_791_713_545E-1,
    -3.504_246_268_278_482E-2,
    -8.574_567_851_546_854E-4,
];
const Q1: &[f64] = &[
    1.577_998_832_564_667_5E1,
    4.539_076_351_288_792E1,
    4.131_720_382_546_72E1,
    1.504_253_856_929_075E1,
    2.504_649_462_083_094,
    -1.421_829_228_547_877_9E-1,
    -3.808_064_076_915_783E-2,
    -9.332_594_808_954_574E-4,
];

// approximation for interval z = sqrt( -2 log y ) between 8 and 64
const P2: &[f64] = &[
    3.237_748_917_769_460_3,
    6.915_228_890_689_842,
    3.938_810_252_924_744_4,
    1.333_034_608_158_075_5,
    2.014_853_895_491_790_8E-1,
    1.237_166_348_178_200_3E-2,
    3.015_815_535_082_354_3E-4,
    2.658_069_746_867_375_5E-6,
    6.239_745_391_849_833E-9,
];
const Q2: &[f64] = &[
    6.024_270_393_647_42,
    3.679_835_638_561_608_7,
    1.377_020_994_890_813_2,
    2.162_369_935_944_966_3E-1,
    1.342_040_060_885_431_8E-2,
    3.280_144_646_821_277_4E-4,
    2.892_478_647_453_806_8E-6,
    6.790_194_080_099_813E-9,
];

pub fn ndtri(y0: f64) -> f64 {
    if !(0.0..=1.0).contains(&y0) {
        return std::f64::NAN;
    }
    if y0 == 0.0 {
        return std::f64::NEG_INFINITY;
    }
    if y0 == 1.0 {
        return std::f64::INFINITY;
    }
    let mut code = true;
    let y = if y0 > 1.0 - EXPN2 {
        code = false;
        1.0 - y0
    } else {
        y0
    };

    if y > EXPN2 {
        let y = y - 0.5;
        let y2 = y * y;
        let x = y + y * (y2 * polevl(y2, P0) / p1evl(y2, Q0));
        return x * S2PI;
    }

    let x = (-2.0 * y.ln()).sqrt();
    let x0 = x - x.ln() / x;

    let z = 1.0 / x;
    let x1 = if x < 8.0 {
        // y > exp(-32) = 1.2664165549e-14
        z * polevl(z, P1) / p1evl(z, Q1)
    } else {
        z * polevl(z, P2) / p1evl(z, Q2)
    };
    let x = x0 - x1;
    if code {
        return -x;
    }
    x
}
