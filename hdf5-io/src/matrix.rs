use anyhow::{format_err, Error};
use hdf5::Group;
use ndarray::s;
use rayon::prelude::*;
use scan_types::label_class::{make_labelclass_from_feature_type_vector, LabelClass};
use scan_types::matrix::{AdaptiveFeatureBarcodeMatrix, GenericFeatureBarcodeMatrix, MatrixMetadata};
use sprs::CsMatI;
use std::collections::BTreeSet;
use std::ops::Range;
use std::path::Path;

type MatrixType = CsMatI<u32, u32>;
pub static FEATURE_TYPE_GENE_EXPRESSION: &str = "Gene Expression";
type FeatureBarcodeMatrix = GenericFeatureBarcodeMatrix<MatrixType>;

/// Read a matrix barcode and feature ids, names, types, and nnz
pub fn read_matrix_metadata(
    filtered_matrix: impl AsRef<Path>,
    retain_feature_like: Option<&str>,
) -> Result<MatrixMetadata, Error> {
    _read_matrix_metadata(filtered_matrix.as_ref(), retain_feature_like)
}

fn _read_matrix_metadata(filtered_matrix: &Path, retain_feature_like: Option<&str>) -> Result<MatrixMetadata, Error> {
    let matrix = hdf5::File::open(filtered_matrix)?.group("matrix")?;
    let barcodes = get_barcodes_between(0, None, &matrix)?;
    let feature_ids = read_features_between("id", 0, None, &matrix)?;
    let feature_names = read_features_between("name", 0, None, &matrix)?;
    let mut feature_types = read_feature_barcode_feature_types(&matrix)?;

    let (feature_ids, feature_names) = if let Some(pattern) = retain_feature_like {
        let features_map = feature_types.remove_unlike(pattern);
        feature_ids
            .into_iter()
            .zip(feature_names)
            .enumerate()
            .filter_map(|(i, v)| if !features_map.contains(&i) { Some(v) } else { None })
            .unzip()
    } else {
        (feature_ids, feature_names)
    };

    let nnz = matrix.dataset("data")?.size();
    return Ok(MatrixMetadata {
        name: filtered_matrix.to_string_lossy().to_string(),
        barcodes,
        feature_ids,
        feature_names,
        feature_types,
        nnz,
    });
}

/// Read a feature barcode matrix with CSC orientation for xena (filtered, analysis h5 file)
fn read_csc_matrix(filtered_matrix: impl AsRef<Path>) -> Result<FeatureBarcodeMatrix, Error> {
    let matrix = hdf5::File::open(&filtered_matrix)?.group("matrix")?;

    let pointers = get_ind_between("indptr", 0, None, &matrix)?;
    let indices = get_ind_between("indices", 0, None, &matrix)?;
    let values = get_values_between(0, None, &matrix)?;

    let barcodes = get_barcodes_between(0, None, &matrix)?;
    let feature_ids = read_features_between("id", 0, None, &matrix)?;
    let feature_names = read_features_between("name", 0, None, &matrix)?;
    let feature_types = read_feature_barcode_feature_types(&matrix)?;

    let csc_mat = match MatrixType::try_new_csc((feature_ids.len(), barcodes.len()), pointers, indices, values) {
        Ok(m) => m,

        // Some matrix files generated by CR 3 apparently have unsorted indices within each cell
        // fall back to a loader that fixes the sorting.
        Err((pointers, indices, values, sprs::errors::StructureError::Unsorted(_))) => {
            match MatrixType::new_from_unsorted_csc((feature_ids.len(), barcodes.len()), pointers, indices, values) {
                Ok(m) => m,
                Err((_, _, _, e)) => return Err(e.into()),
            }
        }
        Err((_, _, _, e)) => return Err(e.into()),
    };

    Ok(FeatureBarcodeMatrix {
        name: filtered_matrix.as_ref().to_string_lossy().to_string(),
        barcodes,
        feature_ids,
        feature_names,
        feature_types,
        matrix: csc_mat,
    })
}

/// Compute the set of features to remove based on name and/or total count.
/// Returns the set of features to remove.
fn compute_genes_filter(
    retain_feature_like: Option<&str>,
    shrink_row: Option<u32>, // Minimum total count in order to retain a feature
    mat: &mut FeatureBarcodeMatrix,
) -> BTreeSet<usize> {
    let features_count = mat.feature_ids.len();

    let mut features_map = match retain_feature_like {
        Some(pattern) => mat.feature_types.remove_unlike(pattern),
        None => BTreeSet::<usize>::new(),
    };

    // find zero count rows
    for j in 0..features_count {
        let Range { start, end } = mat.matrix.indptr().outer_inds(j);
        let (s, e) = (start as usize, end as usize);
        if !features_map.contains(&j)
            && mat.matrix.data()[s..e].iter().fold(0u64, |acc, &y| acc + y as u64) < (shrink_row.unwrap_or(0) as u64)
        {
            features_map.insert(j);
        }
    }

    features_map
}

pub fn read_adaptive_csr_matrix(
    filtered_matrix: impl AsRef<Path>,
    retain_feature_like: Option<&str>,
    shrink_row: Option<u32>,
) -> Result<(AdaptiveFeatureBarcodeMatrix, BTreeSet<usize>), Error> {
    _read_adaptive_csr_matrix(filtered_matrix.as_ref(), retain_feature_like, shrink_row)
}

fn _read_adaptive_csr_matrix(
    filtered_matrix: &Path,
    retain_feature_like: Option<&str>,
    shrink_row: Option<u32>,
) -> Result<(AdaptiveFeatureBarcodeMatrix, BTreeSet<usize>), Error> {
    let mut mat = read_csc_matrix(filtered_matrix)?;
    mat.matrix = mat.matrix.to_csr();

    let (features_count, cells_count) = (mat.feature_ids.len(), mat.barcodes.len());

    let features_map = compute_genes_filter(retain_feature_like, shrink_row, &mut mat);

    let compressed_vecs = (0..(features_count))
        .into_par_iter()
        .filter(|j| !features_map.contains(j))
        .map(|j| {
            let Range { start, end } = mat.matrix.indptr().outer_inds(j);
            let (s, e) = (start as usize, end as usize);
            let mut convert_val = Vec::new();
            let mut convert_index = Vec::new();
            for cell_pos in s..e {
                convert_index.push(mat.matrix.indices()[cell_pos]);
                convert_val.push(mat.matrix.data()[cell_pos]);
            }

            let vec = sqz::AdaptiveVec::new(cells_count, &convert_val, &convert_index);
            assert_eq!(vec.nnz(), e - s);
            vec
        })
        .collect();

    let feature_ids_clean: Vec<String> = mat
        .feature_ids
        .par_iter()
        .enumerate()
        .filter(|&item| !features_map.contains(&item.0))
        .map(|(_, val)| val.clone())
        .collect::<Vec<String>>();

    let feature_names_clean: Vec<String> = mat
        .feature_names
        .par_iter()
        .enumerate()
        .filter(|&item| !features_map.contains(&item.0))
        .map(|(_, val)| val.clone())
        .collect::<Vec<String>>();

    let adaptive_mat = sqz::AdaptiveMat::new(
        feature_ids_clean.len(),
        mat.barcodes.len(),
        sprs::CompressedStorage::CSR,
        compressed_vecs,
    );

    Ok((
        AdaptiveFeatureBarcodeMatrix {
            name: mat.name.clone(),
            barcodes: mat.barcodes,
            feature_ids: feature_ids_clean,
            feature_names: feature_names_clean,
            feature_types: mat.feature_types,
            matrix: adaptive_mat,
        },
        features_map,
    ))
}

fn read_feature_barcode_feature_types(matrix: &Group) -> Result<LabelClass, Error> {
    let feature_types = read_features_between("feature_type", 0, None, matrix)?;
    make_labelclass_from_feature_type_vector(&feature_types)
}

/// Return matrix group for h5
pub fn get_matrix(file_name: &str) -> Result<Group, Error> {
    match hdf5::File::open(file_name)?.group("matrix") {
        Ok(g) => Ok(g),
        Err(e) => Err(format_err!("can't find matrix in file {} {}", &file_name, e)),
    }
}
// // Read the complete list of feature by name (in order)
pub fn read_features_between(
    name: &str,
    start: isize,
    end: Option<isize>,
    matrix: &Group,
) -> Result<Vec<String>, Error> {
    let dataset = matrix.group("features")?.dataset(name)?;
    let data: Vec<hdf5::types::FixedAscii<256>> = match end {
        Some(e) => dataset.read_slice_1d(s![start..e])?.to_vec(),
        None => dataset.read_slice_1d(s![start..])?.to_vec(),
    };
    let data = data.iter().map(|v| v.as_str().to_owned()).collect::<Vec<String>>();
    //nfo!(" type {:#?}", data);
    Ok(data)
}

// // Return the complete array of CSC pointers (len should be number of columns in sparse matrix + 1)
pub fn get_ind_between(name: &str, start: isize, end: Option<isize>, matrix: &Group) -> Result<Vec<u32>, Error> {
    //let mut slice;
    let dataset = matrix.dataset(name)?;
    let data: Vec<u32> = match end {
        Some(e) => dataset.read_slice_1d(s![start..e])?.to_vec(),
        None => dataset.read_slice_1d(s![start..])?.to_vec(),
    };
    Ok(data)
}
// Return all nonzero matrix values for the compressed-sparse row matrix in row order.
pub fn get_values_between(start: isize, end: Option<isize>, matrix: &Group) -> Result<Vec<u32>, Error> {
    let name = "data";
    let dataset = matrix.dataset(name)?;
    let data: Vec<f64> = match end {
        Some(e) => dataset.read_slice_1d(s![start..e])?.to_vec(),
        None => dataset.read_slice_1d(s![start..])?.to_vec(),
    };
    let data = data.iter().map(|&v| v as u32).collect();
    //nfo!(" type {:#?}", data);
    Ok(data)
}

pub fn get_barcodes_between(start: isize, end: Option<isize>, matrix: &Group) -> Result<Vec<String>, Error> {
    const MAX_BARCODE_AND_GEM_GROUP_LEN: usize = 44 + 2;
    let name = "barcodes";
    let dataset = matrix.dataset(name)?;
    let data: Vec<hdf5::types::FixedAscii<MAX_BARCODE_AND_GEM_GROUP_LEN>> = match end {
        Some(e) => dataset.read_slice_1d(s![start..e])?.to_vec(),
        None => dataset.read_slice_1d(s![start..])?.to_vec(),
    };
    let data = data.iter().map(|v| v.as_str().to_owned()).collect::<Vec<String>>();
    Ok(data)
}

// Read UMI counts by reading the entire CSC matrix to determine value sums per cell.
pub fn read_umi_counts_from_matrix(matrix: &Group) -> Result<Vec<u32>, Error> {
    let csc_pointers = get_ind_between("indptr", 0, None, matrix)?;
    let barcode_count = get_barcodes_between(0, None, matrix)?.len();
    let mut umi_counts: Vec<u32> = vec![0u32; barcode_count];

    // scan of the CSC matrix

    let stride = 2000;
    for index in (0..csc_pointers.len()).step_by(stride) {
        let mut end_index = index + stride;
        if end_index >= csc_pointers.len() - 1 {
            end_index = csc_pointers.len() - 1
        }
        let block_start = csc_pointers[index];
        let block_end = csc_pointers[end_index];
        let values_block = get_values_between(block_start as isize, Some(block_end as isize), matrix)?;
        for k in 0..end_index - index {
            let cell_start = (csc_pointers[k + index] - block_start) as usize;
            let cell_end = (csc_pointers[k + index + 1] - block_start) as usize;
            umi_counts[k + index] = values_block[cell_start..cell_end].iter().sum();
        }
    }
    Ok(umi_counts)
}

#[cfg(test)]
mod test {
    use super::{
        compute_genes_filter, make_labelclass_from_feature_type_vector, read_csc_matrix, FeatureBarcodeMatrix,
        MatrixType,
    };

    /// Old cellranger may put out h5 files that don't have sorted indexes within each column
    #[test]
    #[ignore] // needs test fixture
    fn test_cr3_matrix_reverse_sorted() {
        let file = "test/ER-0114-T3.h5";
        let mat = read_csc_matrix(file).unwrap();

        let bc_idx = mat
            .barcodes
            .iter()
            .enumerate()
            .find(|(_idx, bc)| *bc == "AAACCTGAGCTAGTGG-1")
            .unwrap()
            .0;
        let feat_idx = mat
            .feature_names
            .iter()
            .enumerate()
            .find(|(_idx, name)| *name == "MALAT1")
            .unwrap()
            .0;

        let v = mat.matrix.get(feat_idx, bc_idx).cloned().unwrap_or(0);

        // hand checked against same file loaded into Seurat for this barcode & feature.
        assert_eq!(v, 71);
    }

    #[test]
    fn test_compute_genes_filter_overflow() {
        let mut mat = FeatureBarcodeMatrix {
            name: "test".into(),
            barcodes: vec!["b1".into(), "b2".into()],
            feature_ids: vec!["f1".into(), "f2".into()],
            feature_names: vec!["f1".into(), "f2".into()],
            feature_types: make_labelclass_from_feature_type_vector(&["t1".into(), "t1".into()]).unwrap(),
            matrix: MatrixType::new_csc(
                (2, 2),
                vec![0, 2, 4],
                vec![0, 1, 0, 1],
                vec![u32::MAX, u32::MAX, u32::MAX, u32::MAX],
            ),
        };
        let remove_feature_map = compute_genes_filter(None, None, &mut mat);
        assert_eq!(remove_feature_map.len(), 0);
    }
}
